# 7장. 함께 모으기

> **소프트웨어 객체는 현실의 객체를** 모방하거나 추상화한 것이 아니라, 단지 의미를 쉽게 유추할 수 있도록 **은유**할 뿐이다.

> 객체지향 세계에서 모든 객체들은 **능동적**이고 **자율적**인 존재이다.

## 객체지향 설계의 관점

💠 **개념 관점** : 도메인을 구성하는 개념과 개념 사이의 관계에 집중
 - 사용자가 도메인을 바라보는 관점을 반영한다. (실제와 유사하게 반영된다.)

💠 **명세 관점** : 인터페이스에 집중
- 사용자 영역인 도메인을 벗어나 개발자 영역인 소프트웨어 객체에 집중한다.
- 객체가 협력을 위해서 **'무엇'** 을 할 수 있는가에 집중한다.
- 인터페이스와 구현 (명세 관점과 구현 관점) 을 분리하는 것이 매우 중요!!!

💠 **구현 관점** : 클래스의 내부 구현에 집중
- 코드 작성
- 객체가 책임을 **'어떻게'** 수행할 것인가에 집중

⇒ 동일한 코드에서 3가지 관점을 모두 포함하는 코드가 좋은 코드다.

⇒ 변경에 유연하게 대응할 수 있는 객체지향 코드

## 객체지향적인 설계&구현 과정
   by. 커피 전문접 도메인

### 개념 관점
1. **구성 객체 파악**
   - 구성 객체를 파악하고 객체들 간의 관계를 파악하는 과정
   - conceptual modeling 과정과 비슷

2. **동적인 객체를 정적인 타입으로 추상화**
   - 복잡성을 줄여준다.
   - 객체들을 동일한 타입의 인스턴스로 분류한다. = 타입의 추상화

3. **타입 간의 관계를 파악**

|    **관계**     | **결합도**  |        **객체 간 결속성**        |       **존재 의존성**        | **클래스 다이어그램 표기**  |
|:-------------:|:--------:|:--------------------------:|:-----------------------:|:-----------------:|
| **포함/합성 관계**  |  매우 높음   | 부분 객체는 전체 객체 없이는 존재할 수 없음  |     전체가 없으면 부분도 사라짐     |     채워진 다이아몬드     |
|   **집합 관계**   |    중간    |     부분 객체는 독립적으로 존재 가능     |  전체가 없어도 부분은 여전히 존재 가능  |      빈 다이아몬드      |
|   **연관 관계**   |    낮음    |   객체들은 서로 독립적이나 상호작용 가능    |      상호작용 시에만 관련됨       |    단순 선 또는 화살표    |
|   **의존 관계**   |  매우 낮음   |   한 객체가 다른 객체에 일시적으로 의존    | 일시적이며, 참조가 끝나면 의존성 사라짐  |      점선 화살표       |

- 집합과 연관이 코드상에서는 차이가 없다. 개념상의 미세한 차이만 구분한 거임.


[//]: # (   - 포함/합성 관계 : 내가 생성)

[//]: # (     - 메뉴 - 메뉴아이템)

[//]: # (   - 연관 관계 : 다른 타입의 인스턴스를 포함하진 않지만 서로 알고 있어야 하는 경우)

[//]: # (     - 오랫동안 상호작용을 지속하는 관계 &#40;객체를 상태로 저장&#41;)

[//]: # (   - 의존 관계 : 한 클래스가 다른 클래스의 기능을 잠시동안 사용. 메서드의 인자로 받음)

[//]: # (     - )

[//]: # (   - 집합 관계 : )

[//]: # (     - 상태값 저장)
   
[//]: # (   바리스타 - 커피 : 얘는 어느 관계일까??)


   <aside>

   📌 캡슐화를 통해 객체의 속성을 감추는 이유는 **'구현과 인터페이스를 분리'**하기 위해서이다.

   이를 통해 변경의 영향을 최소화할 수 있고, 변화에 유연한 객체지향 설계를 할 수 있다.

   (유지보수성. 변경이 발생했을 때 코드를 좀 더 수월하게 수정하기 위함)

   </aside>
   
   ⇒ 결과물 : 도메인 모델 


### 명세 관점
4. **협력 설계하기 (명세 관점) by. 메시지**
   1. 메시지를 설계
   2. 메시지가 객체를 선택한다.
      
      = 객체는 메시지를 처리할 책임을 맡게 되고, 메시지는 객체의 공용 인터페이스에 포함된다.
   3. 만약 메시지를 수신한 객체가 스스로 할 수 없는 일이 있다면 다른 객체에게 이를 요청하도록 한다.

      (이때도 `전송할 메시지 정의 → 객체 선택` 순서!)
   
   ⇒ 결과물 : 커뮤니케이션 다이어그램
5. **각 객체의 공용 인터페이스를 구현할 수 있을 정도로 메시지를 상세하게 정제하기**
   - 각 객체가 수신 가능한 메시지의 집합 = 객체의 인터페이스


### 구현 관점
6. **클래스의 속성과 메서드를 구현하자**
  - 동적인 객체를 클래스를 이용하여 정적인 타입으로 구현하자
  - 구현 도중 객체의 인터페이스가 변경될 수 있다.
  - 설계를 간단히 끝내고 최대한 빨리 구현에 돌입하라.
    
      설계가 잘 안 그려지면 코드를 작성해가며 협력을 설계하라 (TDD)
    
   ⇒ 결과물 : 클래스 다이어그램

<aside>

    📌 캡슐화를 통해 객체의 속성을 감추는 이유는 '구현과 인터페이스를 분리'하기 위해서이다.

      이를 통해 변경의 영향을 최소화할 수 있고, 변화에 유연한 객체지향 설계를 할 수 있다.

      (유지보수성. 변경이 발생했을 때 코드를 좀 더 수월하게 수정하기 위함)

</aside>