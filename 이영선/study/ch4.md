# 4장. 역할, 책임, 협력

> 객체의 문맥, 즉 객체들 간의 협력이 객체의 행동 방식을 결정한다.

- 조화를 이루며 적극적으로 상호작용하는 협력적인 객체를 만들어야 한다!
- 어떤 협력에 참여하는지가 객체의 행동을 결정하고, 객체의 행동이 필요한 상태를 결정한다.

## 협력

- 협력은 A 객체가 B 객체에게 도움을 요청하고, B 객체가 필요한 지식이나 서비스를 A 객체에게 제공함으로써 수행된다.
- B 객체가 특정 요청을 받아들일 수 있는 이유는 응답에 필요한 지식과 행동 방식을 가지고 있기 떄문이다.

  즉, 요청과 응답은 협력에 참여하는 객체가 수행할 책임을 정의한다.

## 책임

- 요청에 대해 적절한 행동을 해야할 의무
- 객체에 의해 정의되는 응집도 있는 행위의 집합
- 객체가 '무엇을 알고 있는가(knowing)' 와 '무엇을 할 수 있는가(doing)' 로 구성된다.

> - 아는 것 (knowing)
>   - 개인적인 정보
>   - 관련된 객체 정보
>   - 자신의 의무
> - 하는 것 (doing)
>   - 객체 생성 또는 의무 수행 (서비스 제공)
>   - 다른 객체에게 역할을 위임
>   - 다른 객체의 활동 제어, 조절

- 객체지향 설계에서는 각 객체에게 적절한 책임을 할당하는 것이 중요하다!
- 메시지를 통해 객체 간 요청과 응답을 전달하는 것은 협력을 위한 유일한 방법이다.
- 책임을 결정한 후, 협력을 구현하는 과정에서 하나의 책임이 여러 메시지로 분할된다. (하나의 책임은 여러 요청/응답 메시지로 이루어져 있다.)

- 결론 : **객체지향 설계에서는 어떤 객체가 어떤 책임을 수행하고, 어떤 객체로부터 메시지를 수신할 것인지 결정하는 것이 가장 중요하다.**

  어떤 클래스나 메서드가 필요한지 결정하는 것은 나아아중에 해도 늦지 않다.

## 역할

- **책임의 집합** (ex. 재판을 시작하는 것, 증언을 요청하는 책임 등을 판사라는 역할이 가지고 있다.)
- 역할을 사용하면 협력을 추상화하여 단순하게 표현할 수 있다. → 협력의 종류 ⬇️, 유연성 ⬆️, 재사용성 ⬆️

  이 때, 해당 역할을 수행할 수 있는 객체라면 어떤 객체라도 대신할 수 있다. 객체를 제한할 필요가 없다.

  = 구체적인 객체로 추상적인 역할을 대체해서 동일한 구조의 협력을 다양한 문맥에서 재사용할 수 있게 된다.
- 역할을 수행할 수 있다 = 동일한 메시지를 이해하고 처리할 수 있다. + 동일한 책임의 집합을 수행할 수 있다. (행동 호환)

- 역할은 구체적인 객체로 대체될 수 있다. 이 때, 구체적인 객체는 주어진 책임의 집합 이외에 더 많은 책임을 가질 수 있다.

  역할 = 일반화, 구체적인 객체 타입 = 특수화

## 객체의 모양을 결정하는 협력

- 객체지향에 대한 오해
    1. 객체는 데이터를 저장하기 위해 존재한다. (X)

  객체에서 데이터란 행위를 수행하는 데 필요한 재료일 뿐이다. **객체의 존재 이유는 행동을 통해 협력에 참여하기 위해서다.**

    2. 객체지향은 클래스 간의 관계를 표현하는 정적인 측면에 중점을 둔다. (X)

  클래스는 객체를 표현, 생성하기 위한 구현 메커니즘에 불과한다. 객체지향의 핵심은 협력에 참여하는 동적인 객체가 협력 안에서 어떤 책임과 역할을 수행할 것인지 결정하는 것이다.

  > 소프트웨어 아키텍처에서 use case description을 작성하고, 거기서 주어를 추출해서 객체 후보를 뽑아낸다. 이 과정이 동적인 객체에 집중하기 위한 과정이구나!!🫢
  >
  > 객체지향 설계에서 use case를 고려하는 것이 정말 중요하다!!

### RDD 과정

1. 시스템이 사용자에게 제공해야하는 시스템 책임을 파악한다.
2. 시스템 책임을 더 작은 책임으로 분할한다.

   = 협력을 설계하자!

   협력을 설계한다는 것은 설계에 참여하는 객체들이 주고받을 **요청과 응답의 흐름을 결정**한다는 것이다. ( = 협력에 필요한 책임을 정의하라.)
3. 책임을 수행할 객체를 선택한 후 책임을 할당한다.

   객체에게 책임을 할당하면 책임은 객체가 외부에 제공하게 될 행동이 된다.

3. 객체에게 책임(행동)을 부여한 뒤에는 그 행동을 수행하는 데 필요한 데이터를 고민해야 한다.
4. 클래스의 구현 방법을 결정해야 한다.

⇒ 즉, 객체의 행위에 초점을 맞추기 위해선 **협력이라는 실행 문맥 안에서 책임을 분배해야 한다.**

> Q. 여기서 구현 방법이라는 건 메서드(행동)를 구체적인 코드로 작성하는 과정을 의미하는 건가?
> 
> A. 넵

## 객체지향 설계 기법

### 1. 책임 주도 설계 (Responsibility-Driven Design)

- 객체의 책임을 중심으로 시스템을 구축하는 설계 방법
- 시스템의 책임을 객체의 책임으로 변환하고, 각 객체가 협력자에게 책임을 위임/할당하는 순차적인 방식으로 협력 공동체를 구축한다.
- 만약 책임을 여러 종류의 객체가 수행할 수 있다면 **추상적인 역할**로 대체된다.

### 2. 디자인 패턴 (Design Pattern)

- 책임 주도 설계의 결과물
- 반복적으로 발생하는 문제와 그 문제에 대한 해법의 쌍으로 정의된다.
- 클래스나 메서드가 아닌 협력에 참여하는 **역할과 책임으로 구성되어 있다.**

### 3. 테스트 주도 개발 (Test-Driven Development)

- 테스트가 아니라 설계를 위한 기법이라고??!!!?!?!?!
- 이 개발 방법의 핵심은 테스트 작성이 아니라, 테스트를 사용해서 **식별된 역할, 책임, 협력이 적합한지 피드백 받는 것이다.**
- 순서 : 실패하는 테스트 작성 → 테스트가 통과하도록 코드 구현 → 리팩토링을 통한 중복 제거
- 팁 : 객체가 이미 존재한다는 가정 하에, **객체에게 어떤 요청을 하고 어떤 응답을 받고 싶은지 먼저 생각해봐**!!! (역할, 책임, 협력 관점에서 객체를 보면서!)
