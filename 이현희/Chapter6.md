# 6장

## 요약
1. 설계는 기능과 구조 2가지를 모두 고려하는 것이다.
2. 객체지향설계가 은유할 객체들은 도메인 모델에서, 객체지향설계가 분배할 책임은 유스케이스에서 나온다.

## 기능보다 구조가 안정적이다
길을 묻는 것과 지도의 예시

기능은 해결 지향적이고, 구조는 문제 지향적이다.

기능보다 구조가 더 바뀔 가능성이 적다. 따라서 구조를 바탕으로 모델을 만들어야 변경 수요가 적다.

설계는 기능(사용자에게 해줄 것, 충분조건)과 구조(제품의 형태, 필요조건)를 적절히 조화시키는 것.

착각하지 말아야 할 점은, 우리는 미래를 예측할 수 없기 때문에 설계 시에 어떤 변화를 예측하기 보다는,
변화를 적게 할 수 있도록 여지를 남기는 방향이 더 좋다.<br>
=> 이 여지를 남기는 방법이 바로 구조를 이용하는 것

## 객체지향 세계 설계를 위한 2가지 재료
객체지향 세계 설계를 위한 2가지 재료는 기능과 구조이다.

이 재료를 얻는 방법
- 기능 => 유스케이스 모델링
- 구조 => 도메인 모델

### 도메인 모델링
도메인 = 사용자가 프로그램을 사용하는 분야<br>
모델 = 필요한 정보만 선택해 단순화 한 것<br>
도메인 모델 = 소프트웨어가 사용되는 분야 내의 개념이나 관계 등을 단순화한 것

도메인 모델은 멘탈 모델의 일종<br>
멘탈모델이란 사람의 마음 속에 가지고 있는 관계/규칙/제약 모델(본능적으로 구축하는 모델이라고 봐도 될 듯)

멘탈모델은 
- 사용자 모델(사용자 관점)
- 디자인 모델(설계 관점)
- 시스템 이미지(통합)
이렇게 3가지로 구성된다.

설계자는 디자인 모델과 사용자 모델을 통해 구축한 시스템 이미지(=제품)을 통해서 사용자의 피드백을 받을 수 있음.

좋은 제품은 사용자 모델을 전부 반영한 제품이고, 소프트웨어로 치면 좋은 코드는 사용자 모델을 전부 반영한 코드이다.

도메인 모델의 3가지 종류를 모델링할 수 있는 유일한 패러다임 = 객체지향<br>
심지어 3가지 종류가 다 비슷해질 수 있음 = 연결완전성

소프트웨어는 현실의 은유이다. 여기서 말하는 현실, 즉 은유의 대상이 바로 도메인 모델이다.<br>
즉 현실 그 자체가 아닌, 사람들이 현실을 보고 만들어낸 멘탈 모델을 옮겨야 하는 것.

도메인 모델은 안정적인 구조를 제공한다.<br>
왜냐하면 사람들은 도메인의 본질적인 것을 잘 알고 있고 이를 통해 멘탈 모델을 만든 것이기 떄문
- 비즈니스가 없어지거나 개편되지 않는 한 안정적으로 유지됨
- 개념 간의 관계는 비즈니스 규칙을 기반으로 하기 때문에 비즈니스 정책이 크게 변경되지 않는 한 안정적으로 유지됨

### 유스케이스 모델링
기능적 요구사항 = 시스템이 사용자에게 제공해야할 기능의 목록을 나열한 것

유스 케이스 모델링 = 사용자가 특정한 '목표'를 가지고 시스템과 '상호작용'하는 흐름을 텍스트로 묘사한 것<br>
사용자의 목표라는 관점을 통해서 그냥 나열된 기능들을 하나로 묶어줌 = 연관된 기능의 집합을 만들 수 있음<br>
한 번의 상호작용을 시나리오라고 함. 시나리오를 묶어주는 걸로도 볼 수 있음

- 다이어그램이 아니고 텍스트 형태임
- 인터페이스와 같이 자주 변하는 내용은 포함하지 않음
- 내부 설계에 대한 내용도 포함하지 않음
- 설계에 대한 힌트만 얻을 수 있을 뿐 일반적인 규칙(명사는 클래스 동사는 메소드 어쩌구..)은 얻을 수 없음

### 도메인 모델, 유스케이스, 책임 주도 설계의 관계
도메인 모델은 책임 주도 설계가 은유할 객체의 모델을 제시하고,<br>
유스케이스는 책임 주도 설계가 분배해야 하는 책임을 제시한다.

내가 책임 주도 설계 부분을 읽으면서, 협력 속에서 적합한 객체에게 적합한 책임을 분배해야한다는 말을 보고<br>
아니 그럼 객체 식별은 어케함??이라는 의문을 가졌었는데 이게 말끔히 해소된 것 같다.

기능적인 요구사항이 변경되면, 책임과 일부 객체 간 대응 관계만 변한다.
객체지향의 큰 장점은 바로, 도메인 모델링 기법 = 도메인을 코드로 옮기는 방법이라는 점이다.<br>
도메인 모델에서 코드로의 변환가능성을 연결완전성이라고 하고<br>
코드에서 도메인 모델로의 변환 가능성을 가역성이라고 한다.

결과적으로, 코드와 도메인 모델은 분리되지 않는다.