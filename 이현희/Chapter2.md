# 2장

## 현실에서의 객체와 소프트웨어에서의 객체
아기도 세상을 "객체"로 본다.
모든 사람이 그렇다. 그러니까 객체지향이라는 컨셉이 그렇게 어렵지 않게 다가오는 것이다.

인간은 물리적인 "객체" 뿐 아니라 추상적인 것도 "객체"로 잘 인식한다.
자동차 뿐 아니라, 어제의 출금내역 오늘의 출금내역도 구분하니까

"객체"란 인간이 분명하게 인지하고 구별할 수 있는 물리적인 또는 개념적인 경계를 지닌 무엇인가다.

그러나 소프트웨어의 "객체"는 현실의 "객체"와는 거리가 멀다.
자동차가 연료 없이 나갈 수 있고, 사람이 날아다닐 수도 있다.

## 객체, 행동, 상태, 식별자
앨리스 즉 "객체"는, "상태"를 가지며 "상태"는 "변경"이 가능하다

"상태"를 변경 시키는 것은 "행동"이다.

"행동"의 결과는 "상태"가 결정한다.
"행동"의 순서가 "결과"에 영향을 미친다.

"상태"가 어떻게 변해도 앨리스 즉 "객체"는, 동일하게 식별할 수 있다.
"객체"는 식별가능한 물리적, 개념적 어떤 것이다.

"객체"는 "식별자", "상태", "행동"을 가진다.

## 행동이 주연, 상태는 조연
"행동"의 결과는 이전의 어떤 행동을 했는지에 따라 달라질 수 있다.

이전에 어떤 "행동"을 했는지를 가장 효과적으로 저장하는 것은 "상태"가 하는 일이다.
만약 "상태"가 없다면, 모든 "행동"을 기록해야함;;

*그림 2.3 이거 선이 없어야 하는 데 있는 거지??*

## 상태
"프로퍼티"는 "상태"의 이름, 스키마 그 자체이고 변경 불가능,
"프로퍼티 값"은 그 상태에 해당하는 값임. 변경 가능함.
그러니까 쉽게 말하면 height = 170 일때, height가 "프로퍼티"이고 170이 "프로퍼티 값"인 것

객체 간의 관계(아마 멤버 변수로 가지고 있는, 포인터를 가진 상태를 말하는 듯)는 "링크"라고 함

따라서 "상태"는 "프로퍼티"나 "링크" 2가지의 형태를 띔
"상태"는 특정 시점에 "객체"가 가진 정보의 집합. 객체의 구조적 특징을 표현.

"객체"는 다른 이에 의해 "상태"가 변경될 수 없음. 다만 간접적으로 "행동"을 요청하는 것으로는 가능.
그러나 "객체"는 "행동"을 통해 자신이 직접 "상태"를 변경하는 것임. 그마저도 거부하려면 거부 가능 → "자율성"

## 행동과 상태의 상호작용
"객체"의 "행동"은 side effect를 가져온다. "상태"를 변화시킨다는 것이다.

"행동"의 결과는 "상태"에 의존적이다. 음료를 마시는 결과가 키에 의존적이다. 키가 변해야 그 결과가 제대로 나오는 것이다.

"객체"의 "행동"은 "상태"에 영향을 받고, "행동"은 "상태"를 바꾼다.
즉 "객체"의 상호작용(="행동")은, 현재 "상태"에 어떻게 의존하는지와 "상태"를 어떻게 바꾸는 지의 관점에서 서술 가능하다.

"상태"를 이용하면 "객체"의 "행동"을 간단하게 설명 가능하다는 뜻이다.
여기서 행동은 메소드니까 "상태"를 이용하면 "객체"의 메소드를 쉽게 작성할 수 있다는 것과 동일함

## 객체 행동의 결과
"객체"가 다른 "객체"와 "협력"하려면 요청("메시지")을 보낸다. 
그런데 이 "메시지"를 수신한 "객체"에서 "메시지"를 처리하기 위한 "행동"을 하게 될 때 나타나는 부수효과는 
수신한 "객체" 뿐 아니라 전송한 "객체"에도 영향이 갈 수 있다.

"객체"의 행동으로 발생하는 결과는 
"객체" 자신의 "상태" 변경과 
"행동" 내에서 "협력"하는 다른 "객체"에 대한 "메시지" 전송 2가지 이다.

## 객체의 자율성과 캡슐화
소프트웨어 세상의 모든 "객체"는 "자율성"을 가지고 있다. 즉, 다 능동적이라는 의미이다.

음료마저도, 자신의 용량을 줄일지 말지는 본인이 선택하는 것이고 앨리스는 그냥 마셨다라는 "행동"만 전달한다.
어떻게 보면 앨리스는 용량이 줄어들 것이라는 것 조차 모른다 그냥 "행동"만 전달하는 것이다.

그 용량을 줄이는 것, 줄일 지 말 지 판단하는 것 모두 음료라는 "자율적"인 "객체"의 몫이다.

## 식별자와 객체/값
"식별자"란, "객체"를 구분하기 위한 "프로퍼티"이다. 각 "객체"마다 당연히 고유한 값을 가지고 변하지 않아야 한다.

"객체"를 구분하기 위한 개념이 따로 필요한 까닭은, "객체"는 "상태"로 구분될 수 없기 때문이다.
"상태"가 같아도 다른 "객체"일 수 있고, 같은 "객체"여도 시간에 따라 "상태"가 변화하기 때문이다.

그러나 "값" 즉, 리터럴은 시간에 따라 변화하는 값이 아니기 때문에 값이 같으면 같다고 본다.

"식별자"를 기반으로 "객체"가 동일한 지 판단할 수 있는 성질을 동일성(identical)이라고 하고,
"값"을 기반으로 두 값이 동일한 지 판단할 수 있는 성질을 동등성(equality)라고 한다.

근데 사실 자바에서는 "값"도 "객체"로 구현되어있긴 함. 바로 Integer 같은 놈.

얘들은 "Value Object"라고 부르고 원래 우리가 "객체"라고 부르던 애들은
"Reference Object" 또는 "Entity"라고 구분해서 부르기도 함.

*어 근데 궁금한 점 생김. 자바에서는 리터럴이나 Value Object를 어떻게 다루지? 스태틱 영역 뭐 그런데에 저장하는 건가?*

## query, command, 기계 객체
"상태"를 조회하는 작업은 "query", "상태"를 변경하는 작업은 "command"
"기계 객체" 개념을 통해 보는
"캡슐화", "링크", "식별자"

## 행동이 젤 중요하다
"행동"이 "상태"를 결정한다.

기능이 있고, 이 기능을 쪼개어 "역할"이 있고, "책임"이 있다. 이 "책임"과 "역할", 기능은 모두 "행동"에서 나온다.
"행동"을 먼저 정의해야 한다.

## 객제지향에 대한 오해 1
객체지향이 현실세계의 "객체"를 모방하고, "추상화"한다는 말은 틀렸다.

소프트웨어의 "객체"는 의인화되어 능동적으로 행동한다.
마치 음료가 자신의 용량을 줄이는 것 처럼.

따라서 객체지향과 현실세계는 닮아있는 거지, 같은 것이 아니다.
은유의 관점에서 받아들여야 한다.